// Imports
use winapi::km::wdm::{
	KPROCESSOR_MODE
};
use winapi::shared::ntdef::{
	NTSTATUS,
	UNICODE_STRING,
	PUNICODE_STRING,
	PCWSTR,
	LUID,
	ULONG,
	BOOLEAN,
	PVOID,
	KIRQL,
	PKIRQL
};
use winapi::um::winnt::{
	SECURITY_IMPERSONATION_LEVEL,
	PSECURITY_DESCRIPTOR,
	LUID_AND_ATTRIBUTES,
	PRIVILEGE_SET
};

//
// Define the major function codes for IRPs.
//
pub const IRP_MJ_CREATE: usize = 0x00;
pub const IRP_MJ_CREATE_NAMED_PIPE: usize = 0x01;
pub const IRP_MJ_CLOSE: usize = 0x02;
pub const IRP_MJ_READ: usize = 0x03;
pub const IRP_MJ_WRITE: usize = 0x04;
pub const IRP_MJ_QUERY_INFORMATION: usize = 0x05;
pub const IRP_MJ_SET_INFORMATION: usize = 0x06;
pub const IRP_MJ_QUERY_EA: usize = 0x07;
pub const IRP_MJ_SET_EA: usize = 0x08;
pub const IRP_MJ_FLUSH_BUFFERS: usize = 0x09;
pub const IRP_MJ_QUERY_VOLUME_INFORMATION: usize = 0x0a;
pub const IRP_MJ_SET_VOLUME_INFORMATION: usize = 0x0b;
pub const IRP_MJ_DIRECTORY_CONTROL: usize = 0x0c;
pub const IRP_MJ_FILE_SYSTEM_CONTROL: usize = 0x0d;
pub const IRP_MJ_DEVICE_CONTROL: usize = 0x0e;
pub const IRP_MJ_INTERNAL_DEVICE_CONTROL: usize = 0x0f;
pub const IRP_MJ_SHUTDOWN: usize = 0x10;
pub const IRP_MJ_LOCK_CONTROL: usize = 0x11;
pub const IRP_MJ_CLEANUP: usize = 0x12;
pub const IRP_MJ_CREATE_MAILSLOT: usize = 0x13;
pub const IRP_MJ_QUERY_SECURITY: usize = 0x14;
pub const IRP_MJ_SET_SECURITY: usize = 0x15;
pub const IRP_MJ_POWER: usize = 0x16;
pub const IRP_MJ_SYSTEM_CONTROL: usize = 0x17;
pub const IRP_MJ_DEVICE_CHANGE: usize = 0x18;
pub const IRP_MJ_QUERY_QUOTA: usize = 0x19;
pub const IRP_MJ_SET_QUOTA: usize = 0x1a;
pub const IRP_MJ_PNP: usize = 0x1b;
pub const IRP_MJ_PNP_POWER: usize = IRP_MJ_PNP; // Obsolete....
pub const IRP_MJ_MAXIMUM_FUNCTION: usize = 0x1b;

//
// Define the various device characteristics flags
//
pub const FILE_REMOVABLE_MEDIA: u32 = 0x00000001;
pub const FILE_READ_ONLY_DEVICE: u32 = 0x00000002;
pub const FILE_FLOPPY_DISKETTE: u32 = 0x00000004;
pub const FILE_WRITE_ONCE_MEDIA: u32 = 0x00000008;
pub const FILE_REMOTE_DEVICE: u32 = 0x00000010;
pub const FILE_DEVICE_IS_MOUNTED: u32 = 0x00000020;
pub const FILE_VIRTUAL_VOLUME: u32 = 0x00000040;
pub const FILE_AUTOGENERATED_DEVICE_NAME: u32 = 0x00000080;
pub const FILE_DEVICE_SECURE_OPEN: u32 = 0x00000100;
pub const FILE_CHARACTERISTIC_PNP_DEVICE: u32 = 0x00000800;
pub const FILE_CHARACTERISTIC_TS_DEVICE: u32 = 0x00001000;
pub const FILE_CHARACTERISTIC_WEBDAV_DEVICE: u32 = 0x00002000;
pub const FILE_CHARACTERISTIC_CSV: u32 = 0x00010000;
pub const FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL: u32 = 0x00020000;
pub const FILE_PORTABLE_DEVICE: u32 = 0x00040000;
pub const FILE_REMOTE_DEVICE_VSMB: u32 = 0x00080000;
pub const FILE_DEVICE_REQUIRE_SECURITY_CHECK: u32 = 0x00100000;

//
// Define Device Object (DO) flags
//
// DO_DAX_VOLUME - If set, this is a DAX volume i.e. the volume supports mapping a file directly
// on the persistent memory device.  The cached and memory mapped IO to user files wouldn't
// generate paging IO.
//
pub const DO_VERIFY_VOLUME: u32 = 0x00000002;
pub const DO_BUFFERED_IO: u32 = 0x00000004;
pub const DO_EXCLUSIVE: u32 = 0x00000008;
pub const DO_DIRECT_IO: u32 = 0x00000010;
pub const DO_MAP_IO_BUFFER: u32 = 0x00000020;
pub const DO_DEVICE_INITIALIZING: u32 = 0x00000080;
pub const DO_SHUTDOWN_REGISTERED: u32 = 0x00000800;
pub const DO_BUS_ENUMERATED_DEVICE: u32 = 0x00001000;
pub const DO_POWER_PAGABLE: u32 = 0x00002000;
pub const DO_POWER_INRUSH: u32 = 0x00004000;
pub const DO_DEVICE_TO_BE_RESET: u32 = 0x04000000;
pub const DO_DAX_VOLUME: u32 = 0x10000000;

//
// Define IRQL levels
//
/// Passive release level
pub const PASSIVE_LEVEL: KIRQL = 0;
/// Lowest interrupt level
pub const LOW_LEVEL: KIRQL = 0;
/// APC interrupt level
pub const APC_LEVEL: KIRQL = 1;
/// Dispatcher level
pub const DISPATCH_LEVEL: KIRQL = 2;
/// CMCI interrupt level
pub const CMCI_LEVEL: KIRQL = 5;
/// Interval clock level
pub const CLOCK_LEVEL: KIRQL = 13;
/// Interprocessor interrupt level
pub const IPI_LEVEL: KIRQL = 14;
/// Deferred Recovery Service level
pub const DRS_LEVEL: KIRQL = 14;
/// Power failure level
pub const POWER_LEVEL: KIRQL = 14;
/// Timer used for profiling.
pub const PROFILING_LEVEL: KIRQL = 15;
/// Highest interrupt level
pub const HIGH_LEVEL: KIRQL = 15;

// ULONG_PTR & PULONG_PTR types
#[allow(non_camel_case_types)]
pub type ULONG_PTR = u64;
#[allow(non_camel_case_types)]
pub type PULONG_PTR = *mut ULONG_PTR;

// PACCESS_TOKEN type
#[allow(non_camel_case_types)]
pub type PACCESS_TOKEN = PVOID;

//
//  Data structure used to capture subject security context
//  for access validations and auditing.
//
//  THE FIELDS OF THIS DATA STRUCTURE SHOULD BE CONSIDERED OPAQUE
//  BY ALL EXCEPT THE SECURITY ROUTINES.
//
#[allow(non_snake_case)]
#[repr(C)]
pub struct SECURITY_SUBJECT_CONTEXT {
	pub ClientToken: PACCESS_TOKEN,
	pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
	pub PrimaryToken: PACCESS_TOKEN,
	pub ProcessAuditId: PVOID
}
#[allow(non_camel_case_types)]
pub type PSECURITY_SUBJECT_CONTEXT = *mut SECURITY_SUBJECT_CONTEXT;

// ACCESS_MASK type
#[allow(non_camel_case_types)]
pub type ACCESS_MASK = ULONG;
#[allow(non_camel_case_types)]
pub type PACCESS_MASK = *mut ACCESS_MASK;

//
// Define types that are not exported.
//
#[allow(non_camel_case_types)]
pub type POBJECT_TYPE = *mut u8;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                  ACCESS_STATE and related structures                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//  Initial Privilege Set - Room for three privileges, which should
//  be enough for most applications.  This structure exists so that
//  it can be embedded in an ACCESS_STATE structure.  Use PRIVILEGE_SET
//  for all other references to Privilege sets.
//
#[allow(non_snake_case)]
#[repr(C)]
pub struct INITIAL_PRIVILEGE_SET {
	pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 3]
}

// ACCESS_STATE structure
// The ACCESS_STATE structure describes the state of an access in progress.
#[allow(non_snake_case)]
#[repr(C)]
pub union U_ACCESS_STATE_PRIVELEGES {
	InitialPrivilegeSet: core::mem::ManuallyDrop<INITIAL_PRIVILEGE_SET>,
	PrivilegeSet: PRIVILEGE_SET
}

#[allow(non_snake_case)]
#[repr(C)]
pub struct ACCESS_STATE {
    pub OperationID: LUID,
    pub SecurityEvaluated: BOOLEAN,
    pub GenerateAudit: BOOLEAN,
    pub GenerateOnClose: BOOLEAN,
    pub PrivilegesAllocated: BOOLEAN,
    pub Flags: ULONG,
    pub RemainingDesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
    pub SubjectSecurityContext: SECURITY_SUBJECT_CONTEXT,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub AuxData: PVOID,
    pub Privileges: U_ACCESS_STATE_PRIVELEGES,
    pub AuditPrivileges: BOOLEAN,
    pub ObjectName: UNICODE_STRING,
    pub ObjectTypeName: UNICODE_STRING
}
#[allow(non_camel_case_types)]
//pub type PACCESS_STATE = *mut ACCESS_STATE;
pub type PACCESS_STATE = PVOID;

// PUBLIC FUNCTIONS ==========================================

// Import extern system functions and vars
#[link(name = "ntoskrnl")]
extern "system" {
	pub fn RtlInitUnicodeString(
		DestinationString: PUNICODE_STRING,
		SourceString: PCWSTR
	);

	pub fn ObReferenceObjectByName(
		ObjectPath: PUNICODE_STRING,
		Attributes: u32,
		PassedAccessState: PACCESS_STATE,
		DesiredAccess: ACCESS_MASK,
		ObjectType: POBJECT_TYPE,
		AccessMode: KPROCESSOR_MODE,
		ParseContext: PVOID,
		ObjectPtr: *mut PVOID
	) -> NTSTATUS;

	pub fn ObDereferenceObject(a: PVOID);

	pub fn KfRaiseIrql(new_irql: KIRQL) -> KIRQL;

	pub fn KeLowerIrql(new_irql: KIRQL);

	pub static mut IoDriverObjectType: *mut POBJECT_TYPE;
}

// Create empty UNICODE_STRING
pub fn zeroed_unicode_string() -> UNICODE_STRING {
	UNICODE_STRING {
        Length: 0u16,
        MaximumLength: 0u16,
        Buffer: core::ptr::null_mut()
    }
}

// KeRaiseIrql winapi macro
#[allow(non_snake_case)]
pub unsafe fn KeRaiseIrql(new_irql: KIRQL, old_irql: PKIRQL) {
	*old_irql = KfRaiseIrql(new_irql);
}

